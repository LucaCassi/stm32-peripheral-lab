Main project idea: take a micro of the series G4 or H7 (or another one with the necessary timers. I will se H753. it is better if at least one is high resolution for some further testing. It is almost mandatory to use an MPU with some advanced timers), set a sincroniation between two timers to control to motors, test it with some fast output pin and an oscilloscope (eventually, it will be easy to escalate the project to use actual motors). I will use tim1 and tim8, both advanced timers.


I will use a H7 micro and a non-public custom board, but i will try to be more general as possible to make it super easy to apply what i say to any board

1) in CubeMX: Configure the system timer: this is very often a first mandatory step, and in my case it means to open RCC, and select a Crystal/Ceramic Resonator as the High Speed Clock. Leave everything else unchanged, since it is way easier to get all the standard setting after modifying the Clock configuration panel: HSE Input frequency should be put at 8MHz (may be different for you!), then you should select for the first mux HSE and for the second one PLLCLK. In this way you can select a SYSCLK of 480MHz, after which both the Clock Configuration and the HSE settings will be automatically updated. Note: if you do not have an external resonator, you can obtain the same result using an internal source. It may be sliglthy less precise, but this project will work super fine nethertheless.

2) In CubeMX: Configure the master timer. It will be the one to trigger the start of the two slaves timer. This is the only way i currently know to force the micro to start two timers exactly in the same instant (I think the worst case scenario is 1 SYSCLOCK time unit of difference??). I will use TIM2, with clock source Internal Clock, prescaler 0, counter mode up, counter period 1, internal clock division CKD No Division and auto-reload preload disable (more on this later). Trigger Ouptut TRGO should be enabled, with the trigger event selection "Update Event". Note that for what i know it is quite uncommon to choose prescaler1 and counter period 1: indeed, if you do like i say you cannot reasonably see the frequency of this timer with an output pin and the oscilloscope. However, this setting allow to have the two slave sincronization as soon as TIM2 is ready to fire. Choosing someting like prescaler 47 and counter period 9999 would be great if you actually want to use TIM2 for something more than just triggering two slaves, but this is not the case here. Note that period 0 is not ok (at least when prescaler is 0?), and counter period 1 is as fast as i can go, with one update event each two ticks of the timer.

3) Configure the first Slave: in my case, the first slave would be tim1; set, in the mode panel, clock source as Internal Clock, then Slave mode as trigger mode and trigger source as ITR0 (note: the trigger source should be the ITR associated with the master time: if your application is different than mine, you shall check this in internet or, even better, in the reference manual).
Note that in some application you may prefer reset mode than trigger mode, since only the former assure you to reset the tim counter. In my small example/application, this is absolutely irrelevant, cause i will use only one trigger signal per application. The difference would be massive however if you have an application in which the two timers do not have exactly the same parameters and are often disabled and reset (you may indeed see a very small drifting in some specific use cases).

4) same configurations for the second slave, which in my case is TIM8


5) Timer configurations: for both timers, i will use these configurations. Note that it is very reasonable to have the same counter settings for both timers, while the number of channels, deadtime, polarity and other details are strongly dependent on the power module and motor used. Always check for tips in the datasheets when deploying similar solutions. Note also that for the dead time, i put in the largest value possible (255), whose correspondance in nanoseconds depend on both the counter settings and the micro datasheet (the meaning of the number should be shown in a table in the reference manual). Especially for power applications, do not reduce the deadtime parameter before having checked the datasheet of the power module used and the reference manual of the micro. Note that auto-reload preload is generally important, especially if, as in my code, you can change from the IDE debug the PWM counter for the phases of both motors.


